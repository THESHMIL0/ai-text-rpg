<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Carrom Pool - Fixed & Improved</title>
  <style>
    * {margin:0;padding:0;box-sizing:border-box;font-family:Arial, sans-serif;-webkit-user-select:none;-moz-user-select:none;user-select:none}
    body {background:linear-gradient(135deg,#1a2a6c,#b21f1f,#fdbb2d);color:white;min-height:100vh;display:flex;justify-content:center;align-items:center;padding:20px}
    .container {width:100%;max-width:500px;height:90vh;background:rgba(0,0,0,.85);border-radius:20px;overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,.5);display:flex;flex-direction:column}
    .header,.game-header,.game-ui {display:flex;justify-content:space-between;align-items:center;padding:15px;background:linear-gradient(to right,#8b4513,#6b3409)}
    .coins {display:flex;align-items:center;gap:5px;font-weight:bold;font-size:1.1rem}
    .game-area {flex:1;display:flex;flex-direction:column;padding:20px;text-align:center;overflow-y:auto}
    .game-title {font-size:2.5rem;margin-bottom:10px;color:#d4af37;text-shadow:2px 2px 0 #000}
    .menu-buttons {display:flex;flex-direction:column;gap:15px;margin:20px 0}
    .menu-btn {padding:15px;font-size:1.1rem;background:linear-gradient(to bottom,#d4af37,#a2853e);color:white;border:none;border-radius:10px;cursor:pointer;font-weight:bold;transition:.3s}
    .menu-btn:hover {transform:translateY(-2px);box-shadow:0 5px 15px rgba(0,0,0,.3)}
    .game-modes {display:flex;justify-content:center;gap:10px;margin-top:15px}
    .mode-btn {padding:8px 12px;background:rgba(255,255,255,.1);border:2px solid #d4af37;border-radius:10px;color:white;cursor:pointer}
    .mode-btn.active {background:#d4af37;color:#000}
    .footer {text-align:center;padding:10px;font-size:.8rem;color:#aaa;border-top:1px solid #444}
    .game-screen {flex:1;display:none;flex-direction:column}
    .board-container {flex:1;position:relative;margin:10px}
    #gameBoard {width:100%;height:100%;display:block;background:#d4af37;border:15px solid #8b4513;border-radius:10px}
    .player-info {display:flex;align-items:center;gap:8px}
    .player-turn {width:14px;height:14px;border-radius:50%;background:#666;transition:.3s}
    .player-turn.active {background:#d4af37}
    .control-btn {background:rgba(255,255,255,.2);border:none;color:white;padding:8px 12px;border-radius:5px;cursor:pointer}
    .power-bar {position:absolute;bottom:20px;left:50%;transform:translateX(-50%);width:200px;height:10px;background:rgba(0,0,0,.3);border-radius:5px;overflow:hidden;display:none}
    .power-fill {height:100%;width:0%;background:linear-gradient(to right,#0f0,#ff0,#f00);transition:width .1s}
    .game-message {position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,.8);padding:12px 25px;border-radius:10px;text-align:center;display:none;z-index:10}
    .instructions {background:rgba(0,0,0,.6);padding:10px;margin:0 10px 10px;border-radius:10px;font-size:.8rem}
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <div class="coins">ü™ô <span id="coins">12,850</span></div>
      <button class="control-btn" id="settingsBtn">‚öôÔ∏è</button>
    </div>

    <!-- Menu -->
    <div class="game-area" id="mainMenu">
      <h1 class="game-title">CARROM POOL</h1>
      <p>Classic Board Game</p>
      <div class="menu-buttons">
        <button class="menu-btn" id="playBtn">üéÆ PLAY NOW</button>
        <button class="menu-btn" id="practiceBtn">üèÜ PRACTICE</button>
        <button class="menu-btn" id="multiplayerBtn">üë• MULTIPLAYER</button>
      </div>
      <div class="game-modes">
        <button class="mode-btn active">CLASSIC</button>
        <button class="mode-btn">DISCO</button>
        <button class="mode-btn">RUSH</button>
      </div>
      <div class="instructions"><b>How to Play:</b> Drag the striker to aim & release to shoot.</div>
    </div>

    <!-- Game Screen -->
    <div class="game-screen" id="gameScreen">
      <div class="game-header">
        <div class="player-info"><div id="p1Indicator" class="player-turn active"></div> P1: <span id="p1Score">0</span></div>
        <div class="player-info"><div id="p2Indicator" class="player-turn"></div> P2: <span id="p2Score">0</span></div>
      </div>
      <div class="board-container">
        <canvas id="gameBoard"></canvas>
        <div class="power-bar" id="powerBar"><div class="power-fill" id="powerFill"></div></div>
        <div class="game-message" id="gameMessage"></div>
      </div>
      <div class="game-ui">
        <button class="control-btn" id="menuBtn">üìã MENU</button>
        <button class="control-btn" id="hintBtn">üí° HINT</button>
        <button class="control-btn" id="undoBtn">‚Ü©Ô∏è UNDO</button>
      </div>
      <div class="instructions"><b>Controls:</b> P1 = White | P2 = Black | Red = Queen (5 pts)</div>
    </div>

    <div class="footer">Carrom Pool ¬© 2025 | Improved</div>
  </div>

  <script>
  document.addEventListener("DOMContentLoaded", () => {
    const mainMenu = document.getElementById("mainMenu");
    const gameScreen = document.getElementById("gameScreen");
    const playBtn = document.getElementById("playBtn");
    const menuBtn = document.getElementById("menuBtn");
    const settingsBtn = document.getElementById("settingsBtn");
    const hintBtn = document.getElementById("hintBtn");
    const undoBtn = document.getElementById("undoBtn");
    const gameBoard = document.getElementById("gameBoard");
    const ctx = gameBoard.getContext("2d");
    const powerBar = document.getElementById("powerBar");
    const powerFill = document.getElementById("powerFill");
    const gameMessage = document.getElementById("gameMessage");
    const p1Indicator = document.getElementById("p1Indicator");
    const p2Indicator = document.getElementById("p2Indicator");
    const p1ScoreEl = document.getElementById("p1Score");
    const p2ScoreEl = document.getElementById("p2Score");
    const coinsEl = document.getElementById("coins");

    let pieces = [], striker, dragging=false, dragX=0, dragY=0, power=0;
    let currentPlayer=1, scores=[0,0], isMoving=false, anim=null, coins=12850;

    const STRIKER_RADIUS=15, PIECE_RADIUS=15, FRICTION=0.98, BOARD_MARGIN=20;
    
    // Physics parameters
    const MIN_VELOCITY = 0.1;
    const ELASTICITY = 0.8; // Bounce factor
    const COLLISION_DAMPING = 0.95; // Energy loss during collisions

    playBtn.onclick=()=>{mainMenu.style.display="none";gameScreen.style.display="flex";initGame();}
    menuBtn.onclick=()=>{if(confirm("Quit game?")){cancelAnimationFrame(anim);gameScreen.style.display="none";mainMenu.style.display="block";}}
    settingsBtn.onclick=()=>showMessage("Settings coming soon");
    hintBtn.onclick=()=>{if(coins>=10){coins-=10;coinsEl.textContent=coins.toLocaleString();showMessage("Try aiming center!")}else showMessage("Not enough coins");}
    undoBtn.onclick=()=>showMessage("Undo not implemented yet");

    function initGame(){
      resizeCanvas();
      scores=[0,0];updateScores();currentPlayer=1;updateIndicators();
      pieces=[];makePieces();
      striker={x:gameBoard.width/2,y:gameBoard.height-60,r:STRIKER_RADIUS,vx:0,vy:0,color:"white"};
      addControls();
      gameLoop();showMessage("Player 1 turn");
    }
    function resizeCanvas(){gameBoard.width=gameBoard.parentElement.clientWidth;gameBoard.height=gameBoard.parentElement.clientHeight;}
    window.onresize=()=>resizeCanvas();

    function makePieces(){
      const cx=gameBoard.width/2,cy=gameBoard.height/2;
      pieces.push({x:cx,y:cy,r:PIECE_RADIUS,color:"red",queen:true,vx:0,vy:0,pocketed:false});
      for(let i=0;i<9;i++)pieces.push({x:cx+Math.cos(i*40*Math.PI/180)*60,y:cy+Math.sin(i*40*Math.PI/180)*60,r:PIECE_RADIUS,color:i%2?"white":"black",vx:0,vy:0,pocketed:false});
    }

    function addControls(){
      ["mousedown","touchstart"].forEach(ev=>gameBoard.addEventListener(ev,startDrag));
      ["mousemove","touchmove"].forEach(ev=>gameBoard.addEventListener(ev,drag));
      ["mouseup","touchend"].forEach(ev=>gameBoard.addEventListener(ev,endDrag));
    }
    function getXY(e){if(e.touches){return{x:e.touches[0].clientX,y:e.touches[0].clientY}}return{x:e.clientX,y:e.clientY}}
    function startDrag(e){if(isMoving)return;const pos=getXY(e);const rect=gameBoard.getBoundingClientRect();const x=pos.x-rect.left,y=pos.y-rect.top;if(Math.hypot(x-striker.x,y-striker.y)<STRIKER_RADIUS*2){dragging=true;dragX=x;dragY=y;powerBar.style.display="block";}}
    function drag(e){if(!dragging)return;const pos=getXY(e);const rect=gameBoard.getBoundingClientRect();dragX=pos.x-rect.left;dragY=pos.y-rect.top;power=Math.min(Math.hypot(dragX-striker.x,dragY-striker.y)/60,1);powerFill.style.width=(power*100)+"%";}
    function endDrag(){if(!dragging)return;dragging=false;powerBar.style.display="none";const dx=striker.x-dragX,dy=striker.y-dragY,dist=Math.hypot(dx,dy);if(dist>5){striker.vx=(dx/dist)*power*18;striker.vy=(dy/dist)*power*18;isMoving=true;}power=0;powerFill.style.width="0%";}

    function updatePhysics(obj){
      obj.x+=obj.vx;
      obj.y+=obj.vy;
      obj.vx*=FRICTION;
      obj.vy*=FRICTION;
      
      // Boundary collision - keep objects inside the board
      if(obj.x < BOARD_MARGIN + obj.r) {
        obj.x = BOARD_MARGIN + obj.r;
        obj.vx = -obj.vx * ELASTICITY;
      }
      if(obj.x > gameBoard.width - BOARD_MARGIN - obj.r) {
        obj.x = gameBoard.width - BOARD_MARGIN - obj.r;
        obj.vx = -obj.vx * ELASTICITY;
      }
      if(obj.y < BOARD_MARGIN + obj.r) {
        obj.y = BOARD_MARGIN + obj.r;
        obj.vy = -obj.vy * ELASTICITY;
      }
      if(obj.y > gameBoard.height - BOARD_MARGIN - obj.r) {
        obj.y = gameBoard.height - BOARD_MARGIN - obj.r;
        obj.vy = -obj.vy * ELASTICITY;
      }
    }

    function resolveCollision(obj1, obj2) {
      const dx = obj2.x - obj1.x;
      const dy = obj2.y - obj1.y;
      const distance = Math.hypot(dx, dy);
      const minDistance = obj1.r + obj2.r;
      
      if (distance < minDistance) {
        // Calculate collision normal
        const nx = dx / distance;
        const ny = dy / distance;
        
        // Separate the objects more aggressively
        const overlap = minDistance - distance;
        obj1.x -= overlap * nx * 0.7;
        obj1.y -= overlap * ny * 0.7;
        obj2.x += overlap * nx * 0.7;
        obj2.y += overlap * ny * 0.7;
        
        // Calculate relative velocity
        const dvx = obj2.vx - obj1.vx;
        const dvy = obj2.vy - obj1.vy;
        
        // Calculate relative velocity in the normal direction
        const speed = dvx * nx + dvy * ny;
        
        // Only resolve if objects are moving towards each other
        if (speed < 0) return;
        
        // Apply collision impulse with damping
        const impulse = (2 * speed) / 2 * COLLISION_DAMPING;
        obj1.vx += impulse * nx;
        obj1.vy += impulse * ny;
        obj2.vx -= impulse * nx;
        obj2.vy -= impulse * ny;
      }
    }

    function checkCollisions(){
      // Track collisions to prevent multiple collisions in the same frame
      const collisionPairs = new Set();
      
      // Check collisions between striker and pieces
      pieces.forEach(p => {
        if(!p.pocketed) {
          const pairKey = `striker-${pieces.indexOf(p)}`;
          if (!collisionPairs.has(pairKey)) {
            resolveCollision(striker, p);
            collisionPairs.add(pairKey);
          }
        }
      });
      
      // Check collisions between pieces
      for(let i = 0; i < pieces.length; i++) {
        if(pieces[i].pocketed) continue;
        for(let j = i+1; j < pieces.length; j++) {
          if(pieces[j].pocketed) continue;
          const pairKey = `${i}-${j}`;
          if (!collisionPairs.has(pairKey)) {
            resolveCollision(pieces[i], pieces[j]);
            collisionPairs.add(pairKey);
          }
        }
      }
    }

    function checkPockets(){
      const pockets=[{x:15,y:15},{x:gameBoard.width-15,y:15},{x:15,y:gameBoard.height-15},{x:gameBoard.width-15,y:gameBoard.height-15}];
      pockets.forEach(pk=>{
        if(Math.hypot(striker.x-pk.x,striker.y-pk.y)<25){showMessage("Foul!");scores[currentPlayer-1]=Math.max(0,scores[currentPlayer-1]-1);resetStriker();}
        pieces.forEach(p=>{if(!p.pocketed&&Math.hypot(p.x-pk.x,p.y-pk.y)<25){p.pocketed=true;if((currentPlayer===1&&p.color==="white")||(currentPlayer===2&&p.color==="black")){scores[currentPlayer-1]++;showMessage("+1 point");}else if(p.queen){scores[currentPlayer-1]+=5;showMessage("Queen! +5");}else{scores[currentPlayer-1]=Math.max(0,scores[currentPlayer-1]-1);showMessage("Foul! -1");}updateScores();}});
      });
    }

    function resetStriker(){striker.x=gameBoard.width/2;striker.y=currentPlayer===1?gameBoard.height-60:60;striker.vx=striker.vy=0;}

    function endTurn(){currentPlayer=currentPlayer===1?2:1;updateIndicators();resetStriker();showMessage("Player "+currentPlayer+" turn");if(scores[0]>=5||scores[1]>=5){let w=scores[0]>=5?1:2;showMessage("Player "+w+" Wins!");setTimeout(()=>{if(confirm("Play again?"))initGame();else{gameScreen.style.display="none";mainMenu.style.display="block";}},2000);}}

    function draw(){
      ctx.clearRect(0,0,gameBoard.width,gameBoard.height);
      ctx.fillStyle="#d4af37";
      ctx.fillRect(0,0,gameBoard.width,gameBoard.height);
      ctx.strokeStyle="#8b4513";
      ctx.lineWidth=12;
      ctx.strokeRect(0,0,gameBoard.width,gameBoard.height);
      
      // Draw pockets
      [{x:15,y:15},{x:gameBoard.width-15,y:15},{x:15,y:gameBoard.height-15},{x:gameBoard.width-15,y:gameBoard.height-15}].forEach(p=>{
        ctx.beginPath();
        ctx.arc(p.x,p.y,25,0,Math.PI*2);
        ctx.fillStyle="black";
        ctx.fill();
      });
      
      // Draw pieces
      pieces.forEach(p=>{
        if(!p.pocketed){
          ctx.beginPath();
          ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
          ctx.fillStyle=p.color;
          ctx.fill();
          ctx.strokeStyle="#000";
          ctx.stroke();
        }
      });
      
      // Draw striker
      ctx.beginPath();
      ctx.arc(striker.x,striker.y,striker.r,0,Math.PI*2);
      ctx.fillStyle="white";
      ctx.fill();
      ctx.strokeStyle="black";
      ctx.stroke();
      
      // Draw aim line
      if(dragging){
        ctx.beginPath();
        ctx.moveTo(striker.x,striker.y);
        ctx.lineTo(dragX,dragY);
        ctx.strokeStyle="rgba(255,255,255,.7)";
        ctx.lineWidth=2;
        ctx.stroke();
      }
    }

    function gameLoop(){
      if(isMoving){
        // Update striker physics
        updatePhysics(striker);
        
        // Update pieces physics
        pieces.forEach(p => {
          if(!p.pocketed) updatePhysics(p);
        });
        
        // Check all collisions
        checkCollisions();
        
        // Check for pocketed pieces
        checkPockets();
        
        // Check if everything has stopped moving
        const strikerMoving = Math.abs(striker.vx) > MIN_VELOCITY || Math.abs(striker.vy) > MIN_VELOCITY;
        const piecesMoving = pieces.some(p => !p.pocketed && (Math.abs(p.vx) > MIN_VELOCITY || Math.abs(p.vy) > MIN_VELOCITY));
        
        if(!strikerMoving && !piecesMoving && isMoving){
          isMoving = false;
          endTurn();
        }
      }
      
      draw();
      anim = requestAnimationFrame(gameLoop);
    }

    function updateScores(){p1ScoreEl.textContent=scores[0];p2ScoreEl.textContent=scores[1];}
    function updateIndicators(){p1Indicator.classList.toggle("active",currentPlayer===1);p2Indicator.classList.toggle("active",currentPlayer===2);}
    function showMessage(txt){gameMessage.textContent=txt;gameMessage.style.display="block";setTimeout(()=>gameMessage.style.display="none",1500);}
  });
  </script>
</body>
</html>