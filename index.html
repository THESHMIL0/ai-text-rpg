<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carrom Pool Game</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        #game-container {
            position: relative;
        }
        #canvas {
            border: 2px solid #333;
            background-color: #8B4513; /* Brown wood-like color for board */
        }
        #turn-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 20px;
        }
        #score {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 20px;
        }
        #message {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 24px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="canvas" width="600" height="600"></canvas>
        <div id="turn-indicator">Player 1's Turn (White)</div>
        <div id="score">Player 1: 0 | Player 2: 0</div>
        <div id="message"></div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const boardSize = 600;
        const pocketRadius = 20;
        const pieceRadius = 15;
        const strikerRadius = 18;
        const friction = 0.98; // Friction factor to slow down pieces
        const pocketPositions = [
            {x: 30, y: 30},
            {x: boardSize - 30, y: 30},
            {x: 30, y: boardSize - 30},
            {x: boardSize - 30, y: boardSize - 30}
        ];

        // Colors
        const boardColor = '#8B4513';
        const lineColor = '#FFD700'; // Gold for lines
        const whitePieceColor = '#FFFFFF';
        const blackPieceColor = '#000000';
        const queenColor = '#FF0000';
        const strikerColor = '#00FFFF'; // Cyan for striker

        let pieces = [];
        let striker = {x: boardSize / 2, y: boardSize - 50, vx: 0, vy: 0, color: strikerColor, radius: strikerRadius, isStriker: true};
        let currentPlayer = 1; // 1 for white, 2 for black
        let scores = {1: 0, 2: 0};
        let queenPocketed = false;
        let isDragging = false;
        let dragStartX, dragStartY;
        let isMoving = false;
        let message = '';

        // Initialize pieces
        function initPieces() {
            pieces = [];
            // Queen in center
            pieces.push({x: boardSize / 2, y: boardSize / 2, vx: 0, vy: 0, color: queenColor, radius: pieceRadius, type: 'queen'});

            // White and black pieces arranged in a pattern
            const centerX = boardSize / 2;
            const centerY = boardSize / 2;
            const offset = pieceRadius * 2 + 5;

            // Inner circle (alternating)
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 / 6) * i;
                const x = centerX + Math.cos(angle) * offset;
                const y = centerY + Math.sin(angle) * offset;
                pieces.push({x, y, vx: 0, vy: 0, color: i % 2 === 0 ? whitePieceColor : blackPieceColor, radius: pieceRadius, type: i % 2 === 0 ? 'white' : 'black'});
            }

            // Outer circle (alternating, more pieces)
            for (let i = 0; i < 12; i++) {
                const angle = (Math.PI * 2 / 12) * i;
                const x = centerX + Math.cos(angle) * offset * 2;
                const y = centerY + Math.sin(angle) * offset * 2;
                pieces.push({x, y, vx: 0, vy: 0, color: i % 2 === 0 ? blackPieceColor : whitePieceColor, radius: pieceRadius, type: i % 2 === 0 ? 'black' : 'white'});
            }
        }

        // Draw the board
        function drawBoard() {
            ctx.fillStyle = boardColor;
            ctx.fillRect(0, 0, boardSize, boardSize);

            // Draw corner pockets
            ctx.fillStyle = '#000';
            pocketPositions.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, pocketRadius, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw lines (for carrom board design)
            ctx.strokeStyle = lineColor;
            ctx.lineWidth = 2;
            // Outer border lines
            ctx.strokeRect(20, 20, boardSize - 40, boardSize - 40);

            // Center circle
            ctx.beginPath();
            ctx.arc(boardSize / 2, boardSize / 2, 50, 0, Math.PI * 2);
            ctx.stroke();

            // Baseline for striker (bottom for player 1, can rotate for player 2 but simplifying)
            ctx.beginPath();
            ctx.moveTo(100, boardSize - 50);
            ctx.lineTo(boardSize - 100, boardSize - 50);
            ctx.stroke();
        }

        // Draw a piece
        function drawPiece(piece) {
            ctx.beginPath();
            ctx.arc(piece.x, piece.y, piece.radius, 0, Math.PI * 2);
            ctx.fillStyle = piece.color;
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // Check if point is inside board bounds
        function isInsideBoard(x, y) {
            return x > pieceRadius && x < boardSize - pieceRadius && y > pieceRadius && y < boardSize - pieceRadius;
        }

        // Check collision between two circles
        function checkCollision(p1, p2) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist < p1.radius + p2.radius;
        }

        // Resolve collision (elastic)
        function resolveCollision(p1, p2) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const nx = dx / dist;
            const ny = dy / dist;
            const relativeVx = p1.vx - p2.vx;
            const relativeVy = p1.vy - p2.vy;
            const speed = relativeVx * nx + relativeVy * ny;

            if (speed < 0) return; // Already separating

            const impulse = 2 * speed / 2; // Assuming equal mass
            p1.vx -= impulse * nx;
            p1.vy -= impulse * ny;
            p2.vx += impulse * nx;
            p2.vy += impulse * ny;
        }

        // Check if piece is pocketed
        function checkPocketed(piece) {
            for (let pocket of pocketPositions) {
                const dx = piece.x - pocket.x;
                const dy = piece.y - pocket.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < pocketRadius - piece.radius + 5) { // +5 for tolerance
                    return true;
                }
            }
            return false;
        }

        // Update physics
        function updatePhysics() {
            // Update striker
            striker.x += striker.vx;
            striker.y += striker.vy;
            striker.vx *= friction;
            striker.vy *= friction;

            // Wall collisions for striker
            if (striker.x - striker.radius < 0 || striker.x + striker.radius > boardSize) {
                striker.vx = -striker.vx;
            }
            if (striker.y - striker.radius < 0 || striker.y + striker.radius > boardSize) {
                striker.vy = -striker.vy;
            }

            // Check if striker pocketed (foul)
            if (checkPocketed(striker)) {
                message = 'Foul! Striker pocketed.';
                resetStriker();
                switchPlayer();
            }

            // Update pieces
            pieces.forEach(piece => {
                piece.x += piece.vx;
                piece.y += piece.vy;
                piece.vx *= friction;
                piece.vy *= friction;

                // Wall collisions
                if (piece.x - piece.radius < 0 || piece.x + piece.radius > boardSize) {
                    piece.vx = -piece.vx;
                }
                if (piece.y - piece.radius < 0 || piece.y + piece.radius > boardSize) {
                    piece.vy = -piece.vy;
                }
            });

            // Check collisions between striker and pieces
            pieces.forEach(piece => {
                if (checkCollision(striker, piece)) {
                    resolveCollision(striker, piece);
                }
            });

            // Check collisions between pieces
            for (let i = 0; i < pieces.length; i++) {
                for (let j = i + 1; j < pieces.length; j++) {
                    if (checkCollision(pieces[i], pieces[j])) {
                        resolveCollision(pieces[i], pieces[j]);
                    }
                }
            }

            // Check pocketed pieces
            let pocketedThisTurn = false;
            pieces = pieces.filter(piece => {
                if (checkPocketed(piece)) {
                    pocketedThisTurn = true;
                    if (piece.type === 'queen') {
                        queenPocketed = true;
                        message = 'Queen pocketed!';
                    } else if (piece.type === (currentPlayer === 1 ? 'white' : 'black')) {
                        scores[currentPlayer]++;
                    } else {
                        // Pocketed opponent's piece, foul or bonus? Simplifying to score for current player
                        scores[currentPlayer]++;
                    }
                    return false;
                }
                return true;
            });

            // Check if all moving stopped
            const allStopped = Math.abs(striker.vx) < 0.1 && Math.abs(striker.vy) < 0.1 &&
                pieces.every(p => Math.abs(p.vx) < 0.1 && Math.abs(p.vy) < 0.1);

            if (allStopped) {
                striker.vx = 0;
                striker.vy = 0;
                pieces.forEach(p => { p.vx = 0; p.vy = 0; });
                isMoving = false;
                if (!pocketedThisTurn) {
                    switchPlayer();
                }
                // If queen pocketed and covered (pocket own piece after), but simplifying
            }

            // Check win condition (all own pieces pocketed + queen if covered)
            const whitesLeft = pieces.filter(p => p.type === 'white').length;
            const blacksLeft = pieces.filter(p => p.type === 'black').length;
            const queenLeft = pieces.some(p => p.type === 'queen');

            if (currentPlayer === 1 && whitesLeft === 0 && (!queenLeft || queenPocketed)) {
                message = 'Player 1 Wins!';
            } else if (currentPlayer === 2 && blacksLeft === 0 && (!queenLeft || queenPocketed)) {
                message = 'Player 2 Wins!';
            }
        }

        // Reset striker position
        function resetStriker() {
            striker.x = boardSize / 2;
            striker.y = currentPlayer === 1 ? boardSize - 50 : 50;
            striker.vx = 0;
            striker.vy = 0;
        }

        // Switch player
        function switchPlayer() {
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            document.getElementById('turn-indicator').textContent = `Player ${currentPlayer}'s Turn (${currentPlayer === 1 ? 'White' : 'Black'})`;
            resetStriker();
        }

        // Draw everything
        function draw() {
            drawBoard();
            pieces.forEach(drawPiece);
            drawPiece(striker);
        }

        // Game loop
        function gameLoop() {
            if (isMoving) {
                updatePhysics();
            }
            draw();
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        // Update UI
        function updateUI() {
            document.getElementById('score').textContent = `Player 1: ${scores[1]} | Player 2: ${scores[2]}`;
            document.getElementById('message').textContent = message;
            setTimeout(() => { message = ''; }, 3000); // Clear message after 3s
        }

        // Mouse events for dragging striker
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Check if clicking on striker and it's not moving
            if (!isMoving && checkCollision({x: mouseX, y: mouseY, radius: 1}, striker)) {
                isDragging = true;
                dragStartX = mouseX;
                dragStartY = mouseY;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Draw aiming line
                draw();
                ctx.beginPath();
                ctx.moveTo(striker.x, striker.y);
                ctx.lineTo(mouseX, mouseY);
                ctx.strokeStyle = '#FF0';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isDragging) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Calculate velocity based on drag distance
                const dx = dragStartX - mouseX;
                const dy = dragStartY - mouseY;
                const power = Math.sqrt(dx * dx + dy * dy) / 10; // Scale power
                striker.vx = dx / 10 * power / 10; // Adjust speed
                striker.vy = dy / 10 * power / 10;

                isDragging = false;
                isMoving = true;
            }
        });

        // Initialize game
        initPieces();
        resetStriker();
        gameLoop();
    </script>
</body>
</html>