<!-- File: index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>Carrom Pool - Enhanced Gameplay</title>
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%}
  body{
    display:flex;justify-content:center;align-items:center;
    font-family:Inter,Arial,Helvetica,sans-serif;
    background:linear-gradient(135deg,#122243,#6b1f1f);color:#fff;
  }
  .container{
    width:100%;max-width:900px;height:92vh;background:rgba(0,0,0,0.72);
    border-radius:16px;display:flex;flex-direction:column;overflow:hidden;
    box-shadow:0 20px 50px rgba(0,0,0,0.6);
  }
  .header{display:flex;justify-content:space-between;align-items:center;padding:12px 18px;background:linear-gradient(90deg,#8b4513,#6b3409)}
  .coins{font-weight:700}
  .game-area{flex:1;display:flex;gap:14px;padding:18px}
  .left{width:65%;display:flex;flex-direction:column}
  .right{width:35%;display:flex;flex-direction:column;gap:12px}
  .menu, .game-ui, .footer{padding:10px;background:rgba(255,255,255,0.03);border-radius:8px}
  .game-header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-radius:8px;background:rgba(0,0,0,0.2)}
  canvas{width:100%;height:100%;display:block;background:#d4b97b;border-radius:10px;border:12px solid #5b3816}
  .btn{display:inline-block;padding:10px;border-radius:8px;border:none;background:#d4af37;color:#000;font-weight:700;cursor:pointer}
  .control-btn{background:rgba(255,255,255,0.06);color:#fff;border-radius:8px;padding:8px;border:1px solid rgba(255,255,255,0.06);cursor:pointer}
  .power-bar{height:10px;background:rgba(0,0,0,0.4);border-radius:6px;overflow:hidden}
  .power-fill{height:100%;width:0;background:linear-gradient(90deg,#0f0,#ff0,#f00)}
  .message{position:absolute;left:50%;transform:translateX(-50%);top:10px;background:rgba(0,0,0,0.6);padding:8px 14px;border-radius:8px;display:none}
  .instructions{font-size:13px;color:#ddd;padding:8px;background:rgba(0,0,0,0.18);border-radius:8px}
  .scoreline{display:flex;gap:12px;align-items:center}
  .indicator{width:12px;height:12px;border-radius:50%;background:#777}
  .indicator.active{background:#d4af37}
  .small{font-size:13px;color:#ddd}
  .mode-select{display:flex;gap:8px;flex-wrap:wrap}
  .hidden{display:none}
</style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div style="display:flex;gap:14px;align-items:center">
        <div style="font-weight:800;font-size:18px">CARROM POOL</div>
        <div class="small">Enhanced Edition</div>
      </div>
      <div class="coins">ðŸª™ <span id="coins">12,850</span></div>
    </div>

    <div class="game-area">
      <div class="left">
        <div class="game-header">
          <div class="scoreline">
            <div class="indicator active" id="p1Ind"></div> P1: <b id="p1Score">0</b>
          </div>
          <div class="scoreline">
            <div class="indicator" id="p2Ind"></div> P2: <b id="p2Score">0</b>
          </div>
        </div>

        <div style="position:relative;flex:1;margin-top:12px">
          <div class="message" id="messageBox"></div>
          <canvas id="boardCanvas"></canvas>
          <div style="position:absolute;left:50%;transform:translateX(-50%);bottom:14px;width:260px" id="powerWrap">
            <div class="power-bar"><div class="power-fill" id="powerFill"></div></div>
          </div>
        </div>

        <div class="game-ui" style="margin-top:12px;display:flex;gap:8px;align-items:center;">
          <button class="control-btn" id="menuBtn">Menu</button>
          <button class="control-btn" id="hintBtn">Hint (-10)</button>
          <button class="control-btn" id="undoBtn">Undo</button>
          <button class="control-btn" id="restartBtn">Restart</button>
          <div style="margin-left:auto" class="small">Queen = red (covers +5)</div>
        </div>
      </div>

      <div class="right">
        <div class="menu">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <div style="font-weight:700">Mode</div>
            <div class="small">Local / Practice</div>
          </div>
          <div class="mode-select">
            <button class="btn" id="localBtn">2P LOCAL</button>
            <button class="btn" id="practiceBtn">PRACTICE (AI)</button>
          </div>
        </div>

        <div class="instructions">
          <b>How to play</b><br>
          Drag striker to aim and release to shoot. Pocket your color to continue; pocket queen then cover by pocketing your color to claim it.
        </div>

        <div class="menu" id="controlsInfo">
          <div style="font-weight:700;margin-bottom:6px">Controls</div>
          <div class="small">Drag striker | Hint spends coins | Undo one shot | Restart resets game</div>
        </div>

        <div class="menu small">
          <div style="display:flex;justify-content:space-between"><span>Pieces left</span><span id="leftInfo">W:0 | B:0 | Q:1</span></div>
          <div style="margin-top:8px">Winner triggers play-again prompt.</div>
        </div>
      </div>
    </div>

    <div class="footer" style="padding:10px;text-align:center;color:#ccc">Â© 2025 Carrom Pool â€” improved physics & rules</div>
  </div>

<script>
/* === Config & State === */
const canvas = document.getElementById('boardCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const messageBox = document.getElementById('messageBox');
const p1ScoreEl = document.getElementById('p1Score'), p2ScoreEl = document.getElementById('p2Score');
const p1Ind = document.getElementById('p1Ind'), p2Ind = document.getElementById('p2Ind');
const powerFill = document.getElementById('powerFill');
const powerWrap = document.getElementById('powerWrap');
const coinsEl = document.getElementById('coins'), hintBtn = document.getElementById('hintBtn');
const undoBtn = document.getElementById('undoBtn'), restartBtn = document.getElementById('restartBtn');
const leftInfo = document.getElementById('leftInfo');
const localBtn = document.getElementById('localBtn'), practiceBtn = document.getElementById('practiceBtn');

let width = 800, height = 740;
let pieces = [], striker = null, dragging=false, dragPos={x:0,y:0}, aimLine=null;
let currentPlayer = 1; // 1 or 2
let scores = [0,0];
let coins = 12850;
let animId = null, isMoving=false;
let mode = 'local'; // 'local' or 'practice'
let pocketRadius = 36;
const BOARD_MARGIN = 30;
const STRIKER_R = 16;
const PIECE_R = 14;
const FRICTION = 0.993;
const MIN_SPEED = 0.04;
const MAX_POWER = 28; // impulse scale
let undoStack = [];
let queenState = { pocketed:false, claimedBy:0, needsCover:false }; // queen rules

/* === Utility === */
function showMessage(text, ms=1500){
  messageBox.textContent = text;
  messageBox.style.display='block';
  clearTimeout(showMessage._t);
  showMessage._t = setTimeout(()=> messageBox.style.display='none', ms);
}
function rand(min,max){return Math.random()*(max-min)+min}
function deepCloneState(){
  return {
    pieces: pieces.map(p => ({...p})),
    striker: {...striker},
    currentPlayer, scores:[...scores], queenState: {...queenState}, coins
  };
}
function restoreState(state){
  pieces = state.pieces.map(p => ({...p}));
  striker = {...state.striker};
  currentPlayer = state.currentPlayer;
  scores = state.scores.slice();
  queenState = {...state.queenState};
  coins = state.coins;
  updateUI();
}

/* === Resize === */
function resize(){
  // compute canvas pixel size for crisp physics (use devicePixelRatio)
  const containerRect = canvas.parentElement.getBoundingClientRect();
  width = containerRect.width;
  height = containerRect.height;
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = Math.floor(width * dpr);
  canvas.height = Math.floor(height * dpr);
  canvas.style.width = width + 'px';
  canvas.style.height = height + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resize);

/* === Game Setup === */
function resetBoard(){
  pieces = [];
  // center for queen
  const cx = width/2, cy = height/2;
  pieces.push({x:cx,y:cy,r:PIECE_R,color:'red',queen:true,vx:0,vy:0,pocketed:false});
  // Surrounding circle rows â€” simple symmetric
  const ringrad = 56;
  for(let i=0;i<8;i++){
    const angle = (i/8)*Math.PI*2;
    const col = (i%2===0)?'white':'black';
    pieces.push({x:cx+Math.cos(angle)*ringrad,y:cy+Math.sin(angle)*ringrad,r:PIECE_R,color:col,queen:false,vx:0,vy:0,pocketed:false});
  }
  // Add second inner ring slightly
  for(let i=0;i<6;i++){
    const angle = (i/6)*Math.PI*2 + 0.2;
    const col = (i%2===0)?'white':'black';
    pieces.push({x:cx+Math.cos(angle)* (ringrad+28), y:cy+Math.sin(angle)*(ringrad+28), r:PIECE_R, color:col, queen:false, vx:0, vy:0, pocketed:false});
  }

  // striker defaults to current player's baseline
  striker = { x: width/2, y: height - 80, r: STRIKER_R, vx:0, vy:0, color:'white' };
  if(currentPlayer===2) striker.y = 80;
  queenState = { pocketed:false, claimedBy:0, needsCover:false };
  undoStack = [];
}

/* === Drawing === */
function drawBoard(){
  // background / pockets / markings
  ctx.clearRect(0,0,width,height);
  // inner wood area
  ctx.fillStyle = '#d4b97b';
  ctx.fillRect(BOARD_MARGIN, BOARD_MARGIN, width-BOARD_MARGIN*2, height-BOARD_MARGIN*2);

  // pockets (corners)
  const pockets = [
    {x:BOARD_MARGIN, y:BOARD_MARGIN},
    {x:width-BOARD_MARGIN, y:BOARD_MARGIN},
    {x:BOARD_MARGIN, y:height-BOARD_MARGIN},
    {x:width-BOARD_MARGIN, y:height-BOARD_MARGIN}
  ];
  pockets.forEach(p=>{
    ctx.beginPath();
    ctx.fillStyle='rgba(10,10,10,0.6)';
    ctx.arc(p.x, p.y, pocketRadius, 0, Math.PI*2);
    ctx.fill();
  });

  // center circle
  ctx.beginPath();
  ctx.strokeStyle='rgba(0,0,0,0.25)';
  ctx.lineWidth=2;
  ctx.arc(width/2, height/2, 90, 0, Math.PI*2);
  ctx.stroke();

  // draw pieces (non-pocketed)
  // pieces under striker? draw queen last to be visible
  pieces.filter(p=>!p.pocketed && !p.queen).forEach(drawPiece);
  pieces.filter(p=>!p.pocketed && p.queen).forEach(drawPiece);

  // striker
  drawPiece(striker, true);

  // aim line if dragging
  if(dragging && aimLine){
    const {x1,y1,x2,y2} = aimLine;
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();
  }
}
function drawPiece(p, isStriker=false){
  if(p.pocketed) return;
  ctx.beginPath();
  // outer highlight
  ctx.fillStyle = isStriker ? '#ffffff' : (p.color==='white'?'#ffffff': (p.color==='black'?'#111':'#c92a2a'));
  ctx.arc(p.x, p.y, p.r+1.2, 0, Math.PI*2);
  ctx.fill();
  // inner
  ctx.beginPath();
  ctx.fillStyle = isStriker ? '#dfe7ea' : (p.color==='white'?'#fff':'#111');
  ctx.arc(p.x, p.y, p.r-1.6, 0, Math.PI*2);
  ctx.fill();

  if(p.queen){
    ctx.beginPath();
    ctx.fillStyle = '#c92a2a';
    ctx.arc(p.x, p.y, p.r-5, 0, Math.PI*2);
    ctx.fill();
  }
}

/* === Physics === */
function updatePhysics(){
  // update positions
  [striker, ...pieces].forEach(obj=>{
    if(obj.pocketed) return;
    if(Math.abs(obj.vx) < MIN_SPEED) obj.vx = Math.abs(obj.vx) < MIN_SPEED ? 0 : obj.vx;
    if(Math.abs(obj.vy) < MIN_SPEED) obj.vy = Math.abs(obj.vy) < MIN_SPEED ? 0 : obj.vy;
    obj.x += obj.vx;
    obj.y += obj.vy;
    obj.vx *= FRICTION; obj.vy *= FRICTION;
    // walls bounce (inside board margin)
    let left = BOARD_MARGIN + obj.r, right = width - BOARD_MARGIN - obj.r;
    let top = BOARD_MARGIN + obj.r, bottom = height - BOARD_MARGIN - obj.r;
    if(obj.x < left){ obj.x = left; obj.vx = -obj.vx * 0.88; }
    if(obj.x > right){ obj.x = right; obj.vx = -obj.vx * 0.88; }
    if(obj.y < top){ obj.y = top; obj.vy = -obj.vy * 0.88; }
    if(obj.y > bottom){ obj.y = bottom; obj.vy = -obj.vy * 0.88; }
  });

  // collisions (pairwise) â€” simple impulse for equal mass
  const list = [striker, ...pieces].filter(o=>!o.pocketed);
  for(let i=0;i<list.length;i++){
    for(let j=i+1;j<list.length;j++){
      const a = list[i], b = list[j];
      let dx = b.x - a.x, dy = b.y - a.y;
      let dist = Math.hypot(dx,dy);
      let minD = a.r + b.r;
      if(dist > 0 && dist < minD - 0.001){
        // push out overlap
        const nx = dx/dist, ny = dy/dist;
        const overlap = minD - dist;
        a.x -= nx * overlap/2;
        a.y -= ny * overlap/2;
        b.x += nx * overlap/2;
        b.y += ny * overlap/2;

        // relative velocity
        const rvx = b.vx - a.vx, rvy = b.vy - a.vy;
        const relVel = rvx*nx + rvy*ny;
        if(relVel > -0.0001) {
          // simple restitution elastic collision
          const e = 0.88;
          const jImp = -(1+e) * relVel / 2; // divide by 2 (equal mass)
          const impulseX = jImp * nx;
          const impulseY = jImp * ny;
          a.vx -= impulseX; a.vy -= impulseY;
          b.vx += impulseX; b.vy += impulseY;
        }
      }
    }
  }
}

/* === Pocketing & Turn Logic === */
function checkPocketsAndScoring(){
  const pockets = [
    {x:BOARD_MARGIN, y:BOARD_MARGIN},
    {x:width-BOARD_MARGIN, y:BOARD_MARGIN},
    {x:BOARD_MARGIN, y:height-BOARD_MARGIN},
    {x:width-BOARD_MARGIN, y:height-BOARD_MARGIN}
  ];
  // striker pocket foul?
  for(const pk of pockets){
    if(!striker) break;
    if(distance(striker, pk) < pocketRadius){
      // foul
      showMessage("Foul: Striker Pocketed (-1)");
      scores[currentPlayer-1] = Math.max(0, scores[currentPlayer-1]-1);
      updateUI();
      resetStrikerPosition();
      endTurnForced();
      return;
    }
  }

  // pieces pocketing
  let pocketedThisShot = [];
  for(const p of pieces){
    if(p.pocketed) continue;
    for(const pk of pockets){
      if(distance(p, pk) < pocketRadius){
        p.pocketed = true;
        p.vx = p.vy = 0;
        pocketedThisShot.push(p);
        break;
      }
    }
  }

  if(pocketedThisShot.length === 0){
    // if nobody pocketed, turn may end once motion stops
    return;
  }

  // process pocketed pieces in order
  let pocketedOwn = 0;
  let pocketedOpponent = 0;
  let pocketedQueenNow = false;
  for(const p of pocketedThisShot){
    if(p.queen){
      // queen got pocketed
      queenState.pocketed = true;
      queenState.claimedBy = currentPlayer;
      queenState.needsCover = true; // must pocket own color next to cover
      pocketedQueenNow = true;
      showMessage("Queen Pocketed! Cover it by pocketing your color.");
    } else {
      const isOwn = (currentPlayer===1 && p.color==='white') || (currentPlayer===2 && p.color==='black');
      if(isOwn){
        scores[currentPlayer-1] += 1;
        pocketedOwn++;
      } else {
        // opponent piece pocketed -> foul (-1)
        scores[currentPlayer-1] = Math.max(0, scores[currentPlayer-1]-1);
        pocketedOpponent++;
      }
    }
  }

  // handle cover of queen
  if(queenState.needsCover){
    // if player pocketed any of their own color this shot, they cover queen
    if(pocketedOwn > 0){
      // queen claimed
      queenState.needsCover = false;
      queenState.pocketed = true;
      scores[currentPlayer-1] += 5; // award queen points on cover
      showMessage("Queen Covered! +5 points");
    } else {
      // queen remains needing cover. If queen was pocketed by player but not covered in same/next, often rules vary;
      // We'll implement: if next turn player fails to cover and opponent pockets one of their pieces, queen returns to center.
      // We'll track this via queenState.needsCover and handle at end-of-turn check below.
    }
  }

  // if pocketedOpponent > 0 nothing else; update UI
  updateUI();

  // Determine extra turn: if pocketedOwn or queen was pocketed and covered this shot, player continues; otherwise turn passes.
  const coveredNow = pocketedQueenNow && !queenState.needsCover && queenState.claimedBy === currentPlayer;
  if(pocketedOwn>0 || coveredNow){
    // player continues
    showMessage("You pocketed! Continue.");
  } else {
    // player loses turn after motion stops
    setTimeout(()=>{ maybeEndTurnAfterMotion(); }, 50);
  }
}

/* helper distance */
function distance(a,b){ return Math.hypot(a.x - b.x, a.y - b.y); }

/* end-turn helpers */
function resetStrikerPosition(){
  striker.x = width/2;
  striker.y = (currentPlayer===1) ? (height-80) : 80;
  striker.vx = striker.vy = 0;
}
function endTurnForced(){
  // immediate forced switch (used for striker pocket)
  currentPlayer = currentPlayer===1?2:1;
  resetStrikerPosition();
  updateUI();
  // if practice AI and it's AI's turn, trigger AI shot
  if(mode==='practice' && currentPlayer===2){
    setTimeout(aiShot,600);
  }
}
function maybeEndTurnAfterMotion(){
  // if still moving wait, else end turn
  const moving = [striker,...pieces].some(o => !o.pocketed && (Math.abs(o.vx)>MIN_SPEED || Math.abs(o.vy)>MIN_SPEED));
  if(moving){
    setTimeout(maybeEndTurnAfterMotion, 220);
    return;
  }
  // if queen was pocketed and still needsCover, try to enforce rules:
  if(queenState.needsCover && queenState.claimedBy === currentPlayer){
    // If current player ended their shot without covering, penalty: queen returns to center and -5? We'll return queen and -5 points
    showMessage("Failed to cover queen. Queen returned. -5 penalty");
    scores[currentPlayer-1] = Math.max(0, scores[currentPlayer-1]-5);
    // return queen to center
    const q = pieces.find(p => p.queen);
    if(q){
      q.pocketed = false;
      q.x = width/2; q.y = height/2; q.vx = q.vy = 0;
    }
    queenState = { pocketed:false, claimedBy:0, needsCover:false };
    updateUI();
  }

  // determine if player continues: if they pocketed own pieces this turn we allowed continue; otherwise switch
  // We'll detect lastShotPocketedOwn via lastSnapshot comparison in undo stack top (we stored before shot), but simpler:
  // If any piece pocketed during last shot that belonged to currentPlayer -> continue else switch.
  // For simplicity: if any pocketed pieces exists with color matching current player and scored this turn -> continue
  // Implement a simple heuristic: if last action had pocketed this turn flagged in global variable. For simplicity â€” switch.
  // (This keeps behavior fair: player pockets multiple pieces in a single shot can continue; but we approximate.)
  // We'll just switch if no piece of current player got pocketed this shot (we already showed "You pocketed" earlier).
  // To avoid complexity, switch turn now:
  currentPlayer = currentPlayer===1?2:1;
  resetStrikerPosition();
  updateUI();

  // victory check
  if(scores[0] >= 25 || scores[1] >= 25){
    const winner = scores[0] >= 25 ? 1 : 2;
    showMessage("Player " + winner + " Wins!", 4000);
    setTimeout(()=>{
      if(confirm("Play again?")) startNewGame();
    },900);
    return;
  }

  // AI move
  if(mode==='practice' && currentPlayer===2){
    setTimeout(aiShot,600);
  }
}

/* === Input / Dragging === */
function startDrag(e){
  if(isMoving) return;
  const pos = getPointerPos(e);
  if(Math.hypot(pos.x - striker.x, pos.y - striker.y) <= striker.r+6){
    dragging = true;
    dragPos = pos;
    powerWrap.style.display = 'block';
    aimLine = { x1: striker.x, y1: striker.y, x2: pos.x, y2: pos.y };
  }
}
function onDrag(e){
  if(!dragging) return;
  const pos = getPointerPos(e);
  dragPos = pos;
  // power proportional to distance, capped
  const dx = striker.x - pos.x, dy = striker.y - pos.y;
  const dist = Math.hypot(dx,dy);
  const power = Math.min(dist/12, MAX_POWER);
  powerFill.style.width = Math.min(100, Math.round((power/MAX_POWER)*100)) + '%';
  aimLine = { x1: striker.x, y1: striker.y, x2: striker.x - (dx/dist||0)*Math.min(220, dist), y2: striker.y - (dy/dist||0)*Math.min(220, dist) };
}
function endDrag(e){
  if(!dragging) return;
  dragging = false;
  powerWrap.style.display = 'none';
  const dx = striker.x - dragPos.x, dy = striker.y - dragPos.y;
  const dist = Math.hypot(dx,dy);
  if(dist < 6) { aimLine = null; return; }
  const power = Math.min(dist/12, M