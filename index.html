<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carrom Pool Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            max-width: 800px;
            width: 100%;
            text-align: center;
        }
        
        header {
            margin-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .score-board {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .player {
            text-align: center;
        }
        
        .player h2 {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }
        
        .score {
            font-size: 2rem;
            font-weight: bold;
        }
        
        .game-area {
            position: relative;
            margin: 0 auto;
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1 / 1;
            background-color: #d4af37;
            border-radius: 10px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            overflow: hidden;
            border: 10px solid #8b4513;
        }
        
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        
        button {
            padding: 12px 24px;
            font-size: 1rem;
            background-color: #ff8c00;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            background-color: #ff6a00;
        }
        
        .instructions {
            margin-top: 20px;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            text-align: left;
            max-width: 500px;
        }
        
        .instructions h3 {
            margin-bottom: 10px;
            text-align: center;
        }
        
        .instructions ul {
            padding-left: 20px;
        }
        
        .instructions li {
            margin-bottom: 8px;
        }
        
        .turn-indicator {
            font-size: 1.2rem;
            margin-top: 10px;
            font-weight: bold;
        }
        
        @media (max-width: 600px) {
            h1 {
                font-size: 2rem;
            }
            
            .score-board {
                flex-direction: column;
                gap: 10px;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            button {
                width: 100%;
                max-width: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Carrom Pool Game</h1>
            <p>A classic board game for your browser</p>
        </header>
        
        <div class="score-board">
            <div class="player">
                <h2>Player 1</h2>
                <div id="player1-score" class="score">0</div>
            </div>
            <div class="player">
                <h2>Player 2</h2>
                <div id="player2-score" class="score">0</div>
            </div>
        </div>
        
        <div class="game-area">
            <canvas id="gameCanvas"></canvas>
        </div>
        
        <div class="turn-indicator" id="turn-indicator">Player 1's Turn</div>
        
        <div class="controls">
            <button id="reset-btn">Reset Game</button>
            <button id="undo-btn">Undo Move</button>
            <button id="hint-btn">Show Hint</button>
        </div>
        
        <div class="instructions">
            <h3>How to Play</h3>
            <ul>
                <li>Drag the striker to aim and release to shoot</li>
                <li>Pocket your pieces (black or white) to score points</li>
                <li>The queen (red) is worth bonus points if pocketed with a follow-up</li>
                <li>First to 25 points wins the game!</li>
            </ul>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size to match its container
            function resizeCanvas() {
                const gameArea = document.querySelector('.game-area');
                canvas.width = gameArea.offsetWidth;
                canvas.height = gameArea.offsetHeight;
                drawGame();
            }
            
            // Initialize variables
            let player1Score = 0;
            let player2Score = 0;
            let currentPlayer = 1;
            let pieces = [];
            let striker = null;
            let isDragging = false;
            let dragStart = {x: 0, y: 0};
            let dragEnd = {x: 0, y: 0};
            let power = 0;
            let gameActive = true;
            
            // Initialize the game
            function initGame() {
                player1Score = 0;
                player2Score = 0;
                currentPlayer = 1;
                updateScores();
                updateTurnIndicator();
                
                // Create pieces
                pieces = [];
                
                // Center circle (red queen)
                pieces.push({x: canvas.width/2, y: canvas.height/2, radius: 15, color: 'red', type: 'queen'});
                
                // White pieces
                const whitePositions = [
                    {x: canvas.width/2, y: canvas.height/2 - 40},
                    {x: canvas.width/2 - 28, y: canvas.height/2 - 28},
                    {x: canvas.width/2 + 28, y: canvas.height/2 - 28},
                    {x: canvas.width/2 - 40, y: canvas.height/2},
                    {x: canvas.width/2 + 40, y: canvas.height/2},
                    {x: canvas.width/2 - 28, y: canvas.height/2 + 28},
                    {x: canvas.width/2 + 28, y: canvas.height/2 + 28},
                    {x: canvas.width/2, y: canvas.height/2 + 40}
                ];
                
                whitePositions.forEach(pos => {
                    pieces.push({x: pos.x, y: pos.y, radius: 15, color: 'white', type: 'piece'});
                });
                
                // Black pieces
                const blackPositions = [
                    {x: canvas.width/2 - 20, y: canvas.height/2 - 50},
                    {x: canvas.width/2 + 20, y: canvas.height/2 - 50},
                    {x: canvas.width/2 - 50, y: canvas.height/2 - 20},
                    {x: canvas.width/2 + 50, y: canvas.height/2 - 20},
                    {x: canvas.width/2 - 50, y: canvas.height/2 + 20},
                    {x: canvas.width/2 + 50, y: canvas.height/2 + 20},
                    {x: canvas.width/2 - 20, y: canvas.height/2 + 50},
                    {x: canvas.width/2 + 20, y: canvas.height/2 + 50}
                ];
                
                blackPositions.forEach(pos => {
                    pieces.push({x: pos.x, y: pos.y, radius: 15, color: 'black', type: 'piece'});
                });
                
                // Create striker
                striker = {
                    x: canvas.width/2,
                    y: canvas.height - 60,
                    radius: 15,
                    color: 'white',
                    stroke: 'black',
                    type: 'striker'
                };
                
                drawGame();
            }
            
            // Draw the game
            function drawGame() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw board
                ctx.fillStyle = '#d4af37';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw border
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 10;
                ctx.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);
                
                // Draw center circle
                ctx.beginPath();
                ctx.arc(canvas.width/2, canvas.height/2, 40, 0, Math.PI * 2);
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw pockets
                const pocketPositions = [
                    {x: 0, y: 0},
                    {x: canvas.width, y: 0},
                    {x: 0, y: canvas.height},
                    {x: canvas.width, y: canvas.height}
                ];
                
                pocketPositions.forEach(pos => {
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 20, 0, Math.PI * 2);
                    ctx.fillStyle = 'black';
                    ctx.fill();
                });
                
                // Draw pieces
                pieces.forEach(piece => {
                    ctx.beginPath();
                    ctx.arc(piece.x, piece.y, piece.radius, 0, Math.PI * 2);
                    ctx.fillStyle = piece.color;
                    ctx.fill();
                    
                    if (piece.stroke) {
                        ctx.strokeStyle = piece.stroke;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                });
                
                // Draw striker
                if (striker) {
                    ctx.beginPath();
                    ctx.arc(striker.x, striker.y, striker.radius, 0, Math.PI * 2);
                    ctx.fillStyle = striker.color;
                    ctx.fill();
                    
                    if (striker.stroke) {
                        ctx.strokeStyle = striker.stroke;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }
                
                // Draw aiming line if dragging
                if (isDragging) {
                    ctx.beginPath();
                    ctx.moveTo(striker.x, striker.y);
                    ctx.lineTo(dragEnd.x, dragEnd.y);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw power indicator
                    const powerLength = Math.sqrt(
                        Math.pow(dragEnd.x - striker.x, 2) + 
                        Math.pow(dragEnd.y - striker.y, 2)
                    );
                    
                    ctx.beginPath();
                    ctx.arc(striker.x, striker.y, powerLength, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(255, 165, 0, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            // Update score displays
            function updateScores() {
                document.getElementById('player1-score').textContent = player1Score;
                document.getElementById('player2-score').textContent = player2Score;
            }
            
            // Update turn indicator
            function updateTurnIndicator() {
                document.getElementById('turn-indicator').textContent = `Player ${currentPlayer}'s Turn`;
            }
            
            // Handle mouse/touch events
            canvas.addEventListener('mousedown', handleStart);
            canvas.addEventListener('touchstart', handleStart, { passive: false });
            
            canvas.addEventListener('mousemove', handleMove);
            canvas.addEventListener('touchmove', handleMove, { passive: false });
            
            canvas.addEventListener('mouseup', handleEnd);
            canvas.addEventListener('touchend', handleEnd);
            
            function handleStart(e) {
                if (!gameActive) return;
                
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                
                dragStart.x = clientX - rect.left;
                dragStart.y = clientY - rect.top;
                
                // Check if striker is being dragged
                const dx = dragStart.x - striker.x;
                const dy = dragStart.y - striker.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < striker.radius) {
                    isDragging = true;
                }
            }
            
            function handleMove(e) {
                if (!isDragging) return;
                
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                
                dragEnd.x = clientX - rect.left;
                dragEnd.y = clientY - rect.top;
                
                drawGame();
            }
            
            function handleEnd(e) {
                if (!isDragging) return;
                
                e.preventDefault();
                isDragging = false;
                
                // Calculate power and direction
                const dx = striker.x - dragEnd.x;
                const dy = striker.y - dragEnd.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                power = Math.min(distance / 5, 20);
                
                // Simulate shot
                simulateShot(dx, dy, power);
                
                // Switch player after a delay
                setTimeout(() => {
                    currentPlayer = currentPlayer === 1 ? 2 : 1;
                    updateTurnIndicator();
                    
                    // Reset striker position
                    striker.x = canvas.width/2;
                    striker.y = currentPlayer === 1 ? canvas.height - 60 : 60;
                }, 2000);
            }
            
            // Simulate shot (simplified)
            function simulateShot(dx, dy, power) {
                // Normalize direction
                const length = Math.sqrt(dx * dx + dy * dy);
                const dirX = dx / length;
                const dirY = dy / length;
                
                // Apply impulse to striker
                const impulseX = dirX * power;
                const impulseY = dirY * power;
                
                // Simple animation
                let animationFrame;
                const animate = () => {
                    // Move striker
                    striker.x += impulseX;
                    striker.y += impulseY;
                    
                    // Check for collisions with walls
                    if (striker.x - striker.radius < 0 || striker.x + striker.radius > canvas.width) {
                        impulseX = -impulseX * 0.8; // Bounce with damping
                    }
                    
                    if (striker.y - striker.radius < 0 || striker.y + striker.radius > canvas.height) {
                        impulseY = -impulseY * 0.8; // Bounce with damping
                    }
                    
                    // Check for pocket
                    if (isInPocket(striker)) {
                        // Striker pocketed - penalty
                        if (currentPlayer === 1) {
                            player1Score = Math.max(0, player1Score - 1);
                        } else {
                            player2Score = Math.max(0, player2Score - 1);
                        }
                        updateScores();
                        striker.x = canvas.width/2;
                        striker.y = currentPlayer === 1 ? canvas.height - 60 : 60;
                        cancelAnimationFrame(animationFrame);
                        return;
                    }
                    
                    // Check for collisions with pieces
                    pieces.forEach(piece => {
                        const pdx = striker.x - piece.x;
                        const pdy = striker.y - piece.y;
                        const distance = Math.sqrt(pdx * pdy + pdy * pdy);
                        
                        if (distance < striker.radius + piece.radius) {
                            // Collision detected
                            if (isInPocket(piece)) {
                                // Piece pocketed - score
                                if (piece.type === 'queen') {
                                    if (currentPlayer === 1) {
                                        player1Score += 5;
                                    } else {
                                        player2Score += 5;
                                    }
                                } else {
                                    if (currentPlayer === 1) {
                                        player1Score += 1;
                                    } else {
                                        player2Score += 1;
                                    }
                                }
                                
                                // Remove piece from board
                                const index = pieces.indexOf(piece);
                                if (index > -1) {
                                    pieces.splice(index, 1);
                                }
                                
                                updateScores();
                            }
                        }
                    });
                    
                    // Apply damping
                    impulseX *= 0.98;
                    impulseY *= 0.98;
                    
                    // Stop animation when slow enough
                    if (Math.abs(impulseX) < 0.1 && Math.abs(impulseY) < 0.1) {
                        cancelAnimationFrame(animationFrame);
                    } else {
                        drawGame();
                        animationFrame = requestAnimationFrame(animate);
                    }
                };
                
                animate();
            }
            
            // Check if a piece is in a pocket
            function isInPocket(piece) {
                const pockets = [
                    {x: 0, y: 0},
                    {x: canvas.width, y: 0},
                    {x: 0, y: canvas.height},
                    {x: canvas.width, y: canvas.height}
                ];
                
               