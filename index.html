<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carrom Pool Game</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        #game-container {
            position: relative;
        }
        #canvas {
            border: 2px solid #333;
            background-color: #8B4513; /* Brown wood-like color for board */
        }
        #turn-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 20px;
        }
        #score {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 20px;
        }
        #message {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 24px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="canvas" width="600" height="600"></canvas>
        <div id="turn-indicator">Player 1's Turn (White)</div>
        <div id="score">Player 1: 0 | Player 2: 0</div>
        <div id="message"></div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const boardSize = 600;
        const pocketRadius = 20;
        const pieceRadius = 15;
        const strikerRadius = 18;
        const friction = 0.98; // Friction factor to slow down pieces
        const pocketPositions = [
            {x: 30, y: 30},
            {x: boardSize - 30, y: 30},
            {x: 30, y: boardSize - 30},
            {x: boardSize - 30, y: boardSize - 30}
        ];

        // Colors
        const boardColor = '#8B4513';
        const lineColor = '#FFD700'; // Gold for lines
        const whitePieceColor = '#FFFFFF';
        const blackPieceColor = '#000000';
        const queenColor = '#FF0000';
        const strikerColor = '#00FFFF'; // Cyan for striker

        let pieces = [];
        let striker = {x: boardSize / 2, y: boardSize - 50, vx: 0, vy: 0, color: strikerColor, radius: strikerRadius, isStriker: true};
        let currentPlayer = 1; // 1 for white, 2 for black
        let scores = {1: 0, 2: 0};
        let queenPocketed = false;
        let isDragging = false;
        let dragStartX, dragStartY;
        let isMoving = false;
        let message = '';

        // Initialize pieces
        function initPieces() {
            pieces = [];
            // Queen in center
            pieces.push({x: boardSize / 2, y: boardSize / 2, vx: 0, vy: 0, color: queenColor, radius: pieceRadius, type: 'queen'});

            // White and black pieces arranged in a pattern
            const centerX = boardSize / 2;
            const centerY = boardSize / 2;
            const offset = pieceRadius * 2 + 5;

            // Inner circle (alternating)
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 / 6) * i;
                const x = centerX + Math.cos(angle) * offset;
                const y = centerY + Math.sin(angle) * offset;
                pieces.push({x, y, vx: 0, vy: 0, color: i % 2 === 0 ? whitePieceColor : blackPieceColor, radius: pieceRadius, type: i % 2 === 0 ? 'white' : 'black'});
            }

            // Outer circle (alternating, more pieces)
            for (let i = 0; i < 12; i++) {
                const angle = (Math.PI * 2 / 12) * i;
                const x = centerX + Math.cos(angle) * offset * 2;
                const y = centerY + Math.sin(angle) * offset * 2;
                pieces.push({x, y, vx: 0, vy: 0, color: i % 2 === 0 ? blackPieceColor : whitePieceColor, radius: pieceRadius, type: i % 2 === 0 ? 'black' : 'white'});
            }
        }

        // Draw the board
        function drawBoard() {
            ctx.fillStyle = boardColor;
            ctx.fillRect(0, 0, boardSize, boardSize);

            // Draw corner pockets
            ctx.fillStyle = '#000';
            pocketPositions.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, pocketRadius, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw lines (for carrom board design)
            ctx.strokeStyle = lineColor;
            ctx.lineWidth = 2;
            // Outer border lines
            ctx.strokeRect(20, 20, boardSize - 40, boardSize - 40);

            // Center circle
            ctx.beginPath();
            ctx.arc(boardSize / 2, boardSize / 2, 50, 0, Math.PI * 2);
            ctx.stroke();

            // Baseline for striker (bottom for player 1, top for player 2)
            ctx.beginPath();
            ctx.moveTo(100, boardSize - 50);
            ctx.lineTo(boardSize - 100, boardSize - 50);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(100, 50);
            ctx.lineTo(boardSize - 100, 50);
            ctx.stroke();
        }

        // Draw a piece
        function drawPiece(piece) {
            ctx.beginPath();
            ctx.arc(piece.x, piece.y, piece.radius, 0, Math.PI * 2);
            ctx.fillStyle = piece.color;
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // Check collision between two circles
        function checkCollision(p1, p2) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist < p1.radius + p2.radius;
        }

        // Resolve collision (elastic)
        function resolveCollision(p1, p2) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const nx = dx / dist;
            const ny = dy / dist;
            const relativeVx = p1.vx - p2.vx;
            const relativeVy = p1.vy - p2.vy;
            const speed = relativeVx * nx + relativeVy * ny;

            if (speed < 0) return; // Already separating

            const impulse = 2 * speed / 2; // Assuming equal mass
            p1.vx -= impulse * nx;
            p1.vy -= impulse * ny;
            p2.vx += impulse * nx;
            p2.vy += impulse * ny;
        }

        // Check if piece is pocketed
        function checkPocketed(piece) {
            for (let pocket of pocketPositions) {
                const dx = piece.x - pocket.x;
                const dy = piece.y - pocket.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < pocketRadius - piece.radius + 5) { // +5 for tolerance
                    return true;
                }
            }
            return false;
        }

        // Update physics
        function updatePhysics() {
            // Update striker
            striker.x += striker.vx;
            striker.y += striker.vy;
            striker.vx *= friction;
            striker.vy *= friction;

            // Wall collisions for striker
            if (striker.x < striker.radius || striker.x > boardSize - striker.radius) {
                striker.vx = -striker.vx;
            }
            if (striker.y < striker.radius || striker.y > boardSize - striker.radius) {
                striker.vy = -striker.vy;
            }

            // Check if striker pocketed (foul)
            if (checkPocketed(striker)) {
                message = 'Foul! Striker pocketed.';
                setTimeout(() => { message = ''; }, 3000);
                resetStriker();
                switchPlayer();
            }

            // Update pieces
            pieces.forEach(piece => {
                piece.x += piece.vx;
                piece.y += piece.vy;
                piece.vx *= friction;
                piece.vy *= friction;

                // Wall collisions
                if (piece.x < piece.radius || piece.x > boardSize - piece.radius) {
                    piece.vx = -piece.vx;
                }
                if (piece.y < piece.radius || piece.y > boardSize - piece.radius) {
                    piece.vy = -piece.vy;
                }
            });

            // Check collisions between striker and pieces
            pieces.forEach(piece => {
                if (checkCollision(striker, piece)) {
                    resolveCollision(striker, piece);
                }
            });

            // Check collisions between pieces
            for (let i = 0; i < pieces.length; i++) {
                for (let j = i + 1; j < pieces.length; j++) {
                    if (checkCollision(pieces[i], pieces[j])) {
                        resolveCollision(pieces[i], pieces[j]);
                    }
                }
            }

            // Check pocketed pieces
            let pocketedThisTurn = false;
            pieces = pieces.filter(piece => {
                if (checkPocketed(piece)) {
                    pocketedThisTurn = true;
                    if (piece.type === 'queen') {
                        queenPocketed = true;
                        message = 'Queen pocketed!';
                        setTimeout(() => { message = ''; }, 3000);
                    } else if (piece.type === (currentPlayer === 1 ? 'white' : 'black')) {
                        scores[currentPlayer]++;
                    } else {
                        scores[currentPlayer]++;
                    }
                    return false;
                }
                return true;
            });

            // Check if all moving stopped
            const allStopped = Math.abs(striker.vx) < 0.1 && Math.abs(striker.vy) < 0.1 &&
                pieces.every(p => Math.abs(p.vx) < 0.1 && Math.abs(p.vy) < 0.1);

            if (allStopped) {
                striker.vx = 0;
                striker.vy = 0;
                pieces.forEach(p => { p.vx = 0; p.vy = 0; });
                isMoving = false;
                if (!pocketedThisTurn) {
                    switchPlayer();
                }
            }

            // Check win condition (all own pieces pocketed + queen if pocketed)
            const whitesLeft = pieces.filter(p => p.type === 'white').length;
            const blacksLeft = pieces.filter(p => p.type === 'black').length;
            const queenLeft = pieces.some(p => p.type === 'queen');

            if (whitesLeft === 0 && (queenPocketed || !queenLeft)) {
                message = 'Player 1 Wins!';
                // No timeout for win message
            } else if (blacksLeft === 0 && (queenPocketed || !queenLeft)) {
                message = 'Player 2 Wins!';
                // No timeout for win message
            }
        }

        // Reset striker position
        function resetStriker() {
            striker.x = boardSize / 2;
            striker.y = currentPlayer === 1 ? boardSize - 50 : 50;
            striker.vx = 0;
            striker.vy = 0;
        }

        // Switch player
        function switchPlayer() {
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            document.getElementById('turn-indicator').textContent = `Player ${currentPlayer}'s Turn (${currentPlayer === 1 ? 'White' : 'Black'})`;
            resetStriker();
        }

        // Draw everything
        function draw() {
            drawBoard();
            pieces.forEach(drawPiece);
            drawPiece(striker);
        }

        // Game loop
        function gameLoop() {
            if (isMoving) {
                updatePhysics();
            }
            draw();
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        // Update UI
        function updateUI() {
            document.getElementById('score').textContent = `Player 1: ${scores[1]} | Player 2: ${scores[2]}`;
            document.getElementById('message').textContent = message;
        }

        // Function to get position from event (mouse or touch)
        function getPosition(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            if (e.type.startsWith('touch')) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        // Start drag
        function startDrag(e) {
            if (isMoving) return;
            e.preventDefault();
            const pos = getPosition(e);
            // Check if clicking near striker
            if (checkCollision({x: pos.x, y: pos.y, radius: 10}, striker)) { // Larger hit area for mobile
                isDragging = true;
                dragStartX = striker.x;
                dragStartY = striker.y;
            }
        }

        // Move drag
        function moveDrag(e) {
            if (!isDragging) return;
            e.preventDefault();
            const pos = getPosition(e);
            // Draw aiming line
            draw();
            const dx = dragStartX - pos.x;
            const dy = dragStartY - pos.y;
            const aimX = dragStartX + dx;
            const aimY = dragStartY + dy;
            ctx.beginPath();
            ctx.moveTo(dragStartX, dragStartY);
            ctx.lineTo(aimX, aimY);
            ctx.strokeStyle = '#FF0';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // End drag
        function endDrag(e) {
            if (!isDragging) return;
            e.preventDefault();
            const pos = getPosition(e);
            // Calculate velocity (made stronger for better play)
            const dx = dragStartX - pos.x;
            const dy = dragStartY - pos.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const power = dist / 5;
            striker.vx = (dx / 5) * (power / 5);
            striker.vy = (dy / 5) * (power / 5);

            isDragging = false;
            isMoving = true;
        }

        // Add event listeners for both mouse and touch
        canvas.addEventListener('mousedown', startDrag);
        canvas.addEventListener('mousemove', moveDrag);
        canvas.addEventListener('mouseup', endDrag);

        canvas.addEventListener('touchstart', startDrag);
        canvas.addEventListener('touchmove', moveDrag);
        canvas.addEventListener('touchend', endDrag);

        // Initialize game
        initPieces();
        resetStriker();
        gameLoop();
    </script>
</body>
</html>